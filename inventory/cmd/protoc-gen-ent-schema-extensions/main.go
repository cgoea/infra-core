// SPDX-FileCopyrightText: (C) 2025 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

// This protoc plugin reads /api/infrainv/infrainv.proto annotations declared on inventory resources /api/*/.proto files
// and applies them to the schema (/internal/ent/schema) generated by entogo.
package main

import (
	"fmt"
	"go/ast"
	"slices"
	_ "unsafe"

	"entgo.io/contrib/entproto"
	"entgo.io/contrib/schemast"
	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/index"
	"github.com/mitchellh/mapstructure"
	"github.com/rs/zerolog"
	"golang.org/x/exp/maps"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/open-edge-platform/infra-core/inventory/v2/pkg/infrainv"
	"github.com/open-edge-platform/infra-core/inventory/v2/pkg/logging"
	"github.com/open-edge-platform/infra-core/inventory/v2/pkg/util/collections"
)

const (
	thisGenerator = "schema-extender"
)

// Generator skips intentionally .proto definitions listed below.
// None of them contain inventory resource requiring transpilers generation.
var excludedProtoPackages = []string{"inventory.v1", "extensions", "status.v1", "ent", "errors"}

var log = logging.GetLogger(thisGenerator).Level(zerolog.InfoLevel)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		log.Trace().Msgf("PATHS: %+v", maps.Keys(gen.FilesByPath))
		filteredFiles := filterFiles(gen.Files)
		log.Trace().Msgf("All files(%d), filtered files: %d", len(gen.Files), len(filteredFiles))
		extensionsBySchema := gatherSchemaExtensions(filteredFiles)
		log.Info().Msgf("Detected extensions: %v", extensionsBySchema)
		if len(extensionsBySchema) > 0 {
			log.Info().Msg("Loading schema directory")
			schemaContext := loadSchemaContext()
			log.Info().Msg("Applying extensions to the schema...")
			applyExtensions(schemaContext, extensionsBySchema)
			log.Info().Msg("Saving updated schema directory")
			saveUpdatedSchema(schemaContext)
		}
		return nil
	})
}

type extensionBySchema map[string][]*infrainv.Index

func gatherSchemaExtensions(filteredFiles []*protogen.File) extensionBySchema {
	extensionsBySchema := extensionBySchema{}
	for _, f := range filteredFiles {
		log.Debug().Msgf("Processing proto file (%v)", f.Desc.Path())
		for _, message := range f.Messages {
			opts, ok := message.Desc.Options().(*descriptorpb.MessageOptions)
			if !ok {
				panic("not good")
			}

			log.Info().Msgf("Processing proto message (%v)", message.Desc.Name())

			extension := proto.GetExtension(opts, infrainv.E_SchemaExtension)
			schemaEx, ok := extension.(*infrainv.SchemaExtension)
			if !ok {
				log.Fatal().Msgf("cannot acquire infrainv.SchemaExtension from: %v", extension)
				continue
			}
			if indices := schemaEx.GetIndexes(); indices != nil {
				extensionsBySchema[string(message.Desc.Name())] = indices
			}
		}
	}
	return extensionsBySchema
}

func filterFiles(files []*protogen.File) []*protogen.File {
	filteredFiles := collections.Filter[*protogen.File](files, func(f *protogen.File) bool {
		if slices.Contains(excludedProtoPackages, string(f.Desc.FullName())) {
			log.Trace().Msgf("Skipping proto file (%v)", f.Desc.Path())
			return false
		}
		return true
	})

	filteredFiles = collections.Filter[*protogen.File](filteredFiles, func(f *protogen.File) bool {
		return f.Generate
	})
	return filteredFiles
}

func applyExtensions(schemaContext *schemast.Context, extensions map[string][]*infrainv.Index) {
	for name, indices := range extensions {
		if !schemaContext.HasType(name) {
			log.Fatal().Msgf("definition of unique key points to unknown resource(%s)", name)
		}

		for _, si := range indices {
			idx := index.Fields(si.Fields...)
			if si.GetUnique() {
				idx = idx.Unique()
			}
			if si.GetName() != "" {
				idx = idx.StorageKey(si.GetName())
			}
			if si.GetPartialIndexCondition() != "" {
				idx.Annotations(entsql.IndexWhere(si.GetPartialIndexCondition()))
			}
			if err := AppendIndex(schemaContext, name, idx); err != nil {
				log.Fatal().Msgf("cannot append index for %s: %v", name, err)
			}
		}
	}
}

func loadSchemaContext() *schemast.Context {
	ctx, err := schemast.Load("./internal/ent/schema")
	if err != nil {
		log.Fatal().Msgf("cannot load schema directory: %v", err)
	}
	return ctx
}

func saveUpdatedSchema(ctx *schemast.Context) {
	if err := ctx.Print("./internal/ent/schema"); err != nil {
		log.Fatal().Msgf("cannot write updated schema: %v", err)
	}
}

// The section below patches some functions in schemast plugin in order to
// enable declarative partial indices implementation

// AppendIndex adds an index to the returned values of the Indexes method of type typeName.
func AppendIndex(c *schemast.Context, typeName string, idx ent.Index) error {
	newIdx, err := Index(idx.Descriptor())
	if err != nil {
		return err
	}
	return appendReturnItem(c, "Indexes", selectorLit("ent", "Index"), typeName, newIdx)
}

//go:linkname strLit entgo.io/contrib/schemast.strLit
func strLit(string) ast.Expr

//go:linkname selectorLit entgo.io/contrib/schemast.selectorLit
func selectorLit(x, sel string) *ast.SelectorExpr

//go:linkname structAttr entgo.io/contrib/schemast.structAttr
func structAttr(name string, val ast.Expr) ast.Expr

//go:linkname protoMsg entgo.io/contrib/schemast.protoMsg
func protoMsg(annot schema.Annotation) (ast.Expr, bool, error)

//go:linkname protoSvc entgo.io/contrib/schemast.protoSvc
func protoSvc(annot schema.Annotation) (ast.Expr, bool, error)

//go:linkname protoField entgo.io/contrib/schemast.protoField
func protoField(annot schema.Annotation) (ast.Expr, bool, error)

//go:linkname protoEnum entgo.io/contrib/schemast.protoEnum
func protoEnum(annot schema.Annotation) (ast.Expr, bool, error)

//go:linkname entSQL entgo.io/contrib/schemast.entSQL
func entSQL(annot schema.Annotation) (ast.Expr, bool, error)

//go:linkname lookupMethod entgo.io/contrib/schemast.(*Context).lookupMethod
func lookupMethod(c *schemast.Context, typeName, methodName string) (*ast.FuncDecl, bool)

//go:linkname appendMethod entgo.io/contrib/schemast.(*Context).appendMethod
func appendMethod(c *schemast.Context, typeName, method string, retType *ast.SelectorExpr) error

//go:linkname returnStmt entgo.io/contrib/schemast.(*Context).returnStmt
func returnStmt(c *schemast.Context, typeName, method string) (*ast.ReturnStmt, error)

//go:linkname sliceWith entgo.io/contrib/schemast.sliceWith
func sliceWith(sel *ast.SelectorExpr, exprs ...ast.Expr) *ast.CompositeLit

type unsupportedAnnotationError struct {
	annot schema.Annotation
}

func (e *unsupportedAnnotationError) Error() string {
	return fmt.Sprintf("schemast: no Annotator configured for annotation %q", e.annot.Name())
}

func newIndexCall(desc *index.Descriptor) *builderCall {
	fields := make([]ast.Expr, 0, len(desc.Fields))
	for _, fld := range desc.Fields {
		fields = append(fields, strLit(fld))
	}
	return &builderCall{
		curr: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("index"),
				Sel: ast.NewIdent("Fields"),
			},
			Args: fields,
		},
	}
}

func toAnnotASTs(annots []schema.Annotation) ([]ast.Expr, error) {
	out := make([]ast.Expr, 0, len(annots))
	for _, annot := range annots {
		a, shouldAdd, err := annotation(annot)
		if err != nil {
			return nil, err
		}
		if !shouldAdd {
			continue
		}
		out = append(out, a)
	}
	return out, nil
}

func Index(desc *index.Descriptor) (*ast.CallExpr, error) {
	idx := newIndexCall(desc)
	if desc.Unique {
		idx.method("Unique")
	}
	if desc.StorageKey != "" {
		idx.method("StorageKey", strLit(desc.StorageKey))
	}
	if len(desc.Annotations) > 0 {
		as, err := toAnnotASTs(desc.Annotations)
		if err != nil {
			return nil, err
		}
		idx.annotate(as...)
	}
	if len(desc.Edges) > 0 {
		var edges []ast.Expr
		for _, e := range desc.Edges {
			edges = append(edges, strLit(e))
		}
		idx.method("Edges", edges...)
	}
	return idx.curr, nil
}

func appendReturnItem(c *schemast.Context, methodName string, ifaceSelector *ast.SelectorExpr,
	typeName string, item ast.Expr,
) error {
	if _, ok := lookupMethod(c, typeName, methodName); !ok {
		if err := appendMethod(c, typeName, methodName, ifaceSelector); err != nil {
			return err
		}
	}
	stmt, err := returnStmt(c, typeName, methodName)
	if err != nil {
		return err
	}
	return appendToReturn(stmt, ifaceSelector, item)
}

func appendToReturn(stmt *ast.ReturnStmt, sel *ast.SelectorExpr, exprs ...ast.Expr) error {
	returned := stmt.Results[0]
	switch r := returned.(type) {
	case *ast.Ident:
		if r.Name != "nil" {
			return fmt.Errorf("schemast: unexpected ident. expected nil got %s", r.Name)
		}
		stmt.Results = []ast.Expr{sliceWith(sel, exprs...)}
	case *ast.CompositeLit:
		r.Elts = append(r.Elts, exprs...)
	default:
		return fmt.Errorf("schemast: unexpected AST component type %T", r)
	}
	return nil
}

func annotation(annot schema.Annotation) (ast.Expr, bool, error) {
	annotators := map[string]schemast.Annotator{
		entproto.MessageAnnotation: protoMsg,
		entproto.ServiceAnnotation: protoSvc,
		entproto.FieldAnnotation:   protoField,
		entproto.EnumAnnotation:    protoEnum,
		"EntSQL":                   entSQL,
		"EntSQLIndexes":            entSQLIndexes,
	}
	fn, ok := annotators[annot.Name()]
	if !ok {
		return nil, false, &unsupportedAnnotationError{annot: annot}
	}
	return fn(annot)
}

func entSQLIndexes(annot schema.Annotation) (ast.Expr, bool, error) {
	m := &entsql.IndexAnnotation{}
	if err := mapstructure.Decode(annot, m); err != nil {
		return nil, false, err
	}
	c := &ast.CompositeLit{
		Type: selectorLit("entsql", "IndexAnnotation"),
	}
	if m.Where != "" {
		c.Elts = append(c.Elts, structAttr("Where", strLit(m.Where)))
	}
	return c, true, nil
}

type builderCall struct {
	curr *ast.CallExpr
}

func (f *builderCall) method(name string, args ...ast.Expr) {
	f.curr = &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   f.curr,
			Sel: ast.NewIdent(name),
		},
		Args: args,
	}
}

func (f *builderCall) annotate(annots ...ast.Expr) {
	if len(annots) > 0 {
		f.method("Annotations", annots...)
	}
}
