// SPDX-FileCopyrightText: (C) 2025 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

// Package cli implements a simple prompt-based terminal UI to interact with
// Inventory resource objects over gRPC.
//
// This code started as an afternoon idea for a demo driver and may not make
// ideal choices for many decisions. On a high level, we're chaining together
// prompts into a crude form of menus of selections and actions. Some more
// generic parts of the code are auto-generated by using reflection on the
// protobuf resource messages. This includes listing and deleting them, but more
// resource specific actions like creating a VM instance are hand-written, as we
// don't yet differentiate between resource edges which need to load and
// reference other objects and scalar fields.
//
// Notes for future development:
//   - Consider using an actual UI framework like github.com/rivo/tview
//   - Auto-gen more code by inspecting the ent annotations on the protobuf messages
//   - Consider writing a protoc plugin instead of using reflection
//
//nolint:all
package cli

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/manifoldco/promptui"
	"golang.org/x/term"

	compute_v1 "github.com/open-edge-platform/infra-core/inventory/v2/pkg/api/compute/v1"
	inv_v1 "github.com/open-edge-platform/infra-core/inventory/v2/pkg/api/inventory/v1"
	inv_client "github.com/open-edge-platform/infra-core/inventory/v2/pkg/client"
	"github.com/open-edge-platform/infra-core/inventory/v2/pkg/logging"
	"github.com/open-edge-platform/infra-core/inventory/v2/pkg/util"
)

var log = logging.GetLogger("cli")

func getTerminalSize() (int, int, error) {
	return term.GetSize(int(os.Stdin.Fd()))
}

func stringContainSearcher(l []menuItem) func(string, int) bool {
	return func(input string, index int) bool {
		return strings.Contains(l[index].Name, input)
	}
}

func CreateVM(
	ctx context.Context,
	client inv_client.InventoryClient,
	name string,
	host *compute_v1.HostResource,
) (*compute_v1.InstanceResource, error) {
	vm := &compute_v1.InstanceResource{
		Kind:           compute_v1.InstanceKind_INSTANCE_KIND_VM,
		Name:           name,
		DesiredState:   compute_v1.InstanceState_INSTANCE_STATE_RUNNING,
		CurrentState:   compute_v1.InstanceState_INSTANCE_STATE_UNSPECIFIED,
		VmMemoryBytes:  2000 * util.Megabyte,
		VmCpuCores:     2,
		VmStorageBytes: 20 * util.Gigabyte,
		Host:           host,
	}
	resp, err := client.Create(ctx, &inv_v1.Resource{Resource: &inv_v1.Resource_Instance{Instance: vm}})
	if err != nil {
		return nil, err
	}
	vm.ResourceId = resp.GetInstance().GetResourceId()

	return vm, nil
}

type menuItem struct {
	Name string
	Next func(arg interface{}) (interface{}, error)
	Arg  interface{}
}

var selectTemplate = &promptui.SelectTemplates{
	Label:    "{{ .Name }}?",
	Active:   "â–¸ {{ .Name | underline }}",
	Inactive: "  {{ .Name }}",
}

var (
	errPromptDone       = errors.New("prompt done")
	errPromptSelectDone = errors.New("select done")
)

func parentPrompt(arg interface{}) (interface{}, error) {
	return arg, errPromptDone
}

func returnSelectedItem(arg interface{}) (interface{}, error) {
	return arg, errPromptSelectDone
}

const (
	labelBack = "<Back>"
)

type Cli struct {
	ctx              context.Context
	client           inv_client.InventoryClient
	lineItemMaxWidth int
}

func NewCli(ctx context.Context, client inv_client.InventoryClient) *Cli {
	width, _, err := getTerminalSize()
	if err != nil {
		log.Fatal().Err(err).Msg("failed to get terminal size")
	}

	return &Cli{
		ctx:              ctx,
		client:           client,
		lineItemMaxWidth: width - 4, // subtract the prompt selector.
	}
}

func (c *Cli) PromptRoot() (interface{}, error) {
	items := []menuItem{
		{Name: "<Exit>", Next: parentPrompt},
		{Name: "Create VM", Next: c.promptCreateVM},
		{Name: "List Hosts", Next: c.PromptListHosts},
		{Name: "List HostNics", Next: c.PromptListHostNics},
		{Name: "List HostStorages", Next: c.PromptListHostStorages},
		{Name: "List HostUSBs", Next: c.PromptListHostUSBs},
		{Name: "List Instances", Next: c.PromptListInstances},
		{Name: "List Workloads", Next: c.PromptListWorkloads},
		{Name: "List WorkloadMembers", Next: c.PromptListWorkloadMembers},

		{Name: "List Sites", Next: c.PromptListSites},
		{Name: "List Regions", Next: c.PromptListRegions},
	}
	rootMenuSelect := promptui.Select{
		Label:     "Select Action",
		Items:     items,
		Searcher:  stringContainSearcher(items),
		Templates: selectTemplate,
		Size:      10,
	}
	for {
		i, _, err := rootMenuSelect.Run()
		if err != nil {
			log.Error().Err(err).Msg("Prompt failed.")
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		}
		if errors.Is(err, errPromptSelectDone) {
			continue
		}
		if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) promptCreateVM(interface{}) (interface{}, error) {
	prompt := promptui.Prompt{
		Label: "New VM Name",
	}
	vmName, err := prompt.Run()
	if err != nil {
		log.Error().Err(err).Msg("Prompt failed.")
		return nil, err
	}

	// Prompt for the Host.
	var host *compute_v1.HostResource
	{
		hosts, err := helperListHosts(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{}
		for _, h := range hosts {
			h.Instance = nil
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, h),
				Next: parentPrompt,
				Arg:  h,
			})
		}
		hostPrompt := promptui.Select{
			Label:     "Select Host to place this VM on:",
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
		}
		i, _, err := hostPrompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		host = items[i].Arg.(*compute_v1.HostResource)
	}

	log.Trace().Msgf("creating VM '%v' ...", vmName)
	vm, err := CreateVM(c.ctx, c.client, vmName, host)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to create VM")
	}
	log.Trace().Msgf("Created VM: %v", vm)

	return vm, nil
}
